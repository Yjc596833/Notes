<!--
 * @Author: your name
 * @Date: 2020-11-10 15:11:26
 * @LastEditTime: 2021-05-19 18:13:17
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \Notes\Redis\下载操作文档.md
-->
https://blog.csdn.net/y_index/article/details/78706771

https://www.geek-share.com/detail/2786467640.html

https://www.cnblogs.com/Lulus/p/7877688.html

https://www.runoob.com/redis/lists-lpush.html  常用网站查询字段

https://www.bilibili.com/video/BV1oW411u75R?p=11&spm_id_from=pageDriver  学习视频

### 分布式的内存数据库

安装命令：redis-server.exe --service-install redis.windows.conf --loglevel verbose

启动服务命令：redis-server.exe  --service-start

关闭服务命令：redis-server.exe  --service-stop

调用命令是：redis-cli.exe -h 127.0.0.1 -p 6379

重新启动redis服务：redis-server redis.windows.conf

#### redis 常用命令

```redis
默认16个数据库，索引从零开始，默认端口6379
select index 切换数据库 
Dbsize 查看当前数据库的key的数量
Keys * 罗列当前数据库的所有key
FLUSHDB 清空当前库
FLUSHALL 清空所有库
Clear 清除屏幕
```

#### 五大数据类型

String: 是redis最基本的类型，可以理解成于Memached一模一样的类型，一个key对应一个value
        string 类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象
        是最基本的数据类型，一个redis中字符串value最多可以是512M
Hash:   是一个键值对集合
        是一个string类型的field和value的映射表，hash特别适合存储对象
List:   

set:

zset(sorted zet:有序集合):不同的是每个元素都会关联一个double类型的分数。
        正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数（score）却可以重复

### 常用操作

#### String

exists:{exists [key]}  是否存在

move:{move [key] [DBIndex]} 将当前库的某个键，移动到其他库 

ttl:{ttl [key]} 返回：-1  无期限    -2  已过期

expire:{expire [key][expirtTime]} 单位秒  

del:{del [key]}

type:{type [key]} 查看key类型

append:{append key value}  如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾
                           如果 key 不存在， APPEND 就简单地将给定 key 设为  value ，就像执行 SET key value 一样

incr:{incr key value} 递增
 
decr:{incr key value} 递减

getrange:{getrange key start end} 获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)

setrange:{setrange key start value}

setnx:{setnx key value} 指定的 key 不存在时，为 key 设置指定的值;如果存在则不生效

mget:{get key1 value1 key2 value2 ...}

mset:{get key1 value1 key2 value2 ...}  只要其中有一个存在，则执行返回（integer）0,都不执行

##### List  [成员是可以重复的，适合经常追加数据，插入，删除数据。但随机取数效率比较低]

lpush:{lpush key value[value ... ]}  将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误

rpush:{rpush key value[value ... ]}  将一个或多个值插入到列表的尾部(最右边)

lrange:{lrange key start end}  返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定

lpop:{lpop key} 用于移除并返回列表的第一个元素 当列表 key 不存在时，返回 nil 

rpop:{rpop key} 用于移除并返回列表的第一个元素 当列表 key 不存在时，返回 nil 

lindex: lindex key index 

llen:llen key

lrem key  count value

ltrim key 开始index结束index,截取指定范围的值后再赋值给key Redis Ltrim 对一个列表进行修剪(trim)，
          就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。
          下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
          你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。

lset key index value  过索引来设置元素的值

linsert  key before|after  pivot  value       [将值 value 插入到列表 key 当中，位于值 pivot 之前或之后]在列表的元素前或者后插入元素

eg:RPOPLPUSH key1 key2

##### Set  [成员是不能重复的，适合经常地随机储存，插入，删除。但是在遍历时效率比较低]
           [Set对每个对象只接受一次，并使用自己内部的排序方法(通常，你只关心某个元素是否属于Set,而不关心它的顺序--否则应该使用List)]

sadd: sadd key value1 value2 ... 将一个或多个成员元素加入到集合汇总，已经存在于集合的成员元素将被忽略

smembers key  返回集合中的所有的成员 

scard key  返回集合中元素的数量

srem key value 删除集合中的元素

srandmember set key count  随机

spop key count  用于移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素

smove set1 set2 member

[差集]
Sdiff 命令返回第一个集合与其他集合之间的差异，也可以认为说第一个集合中独有的元素

eg:sadd set01 1 2 3 4   sadd set02 3 4 a b   sdiff set01 set02 => 返回为 1 2    sdiff set02 set01 => 返回为 a b

[交集]
eg:sinter set01 set02

[并集]
eg:sunion set01 set02

##### Hash [很重要]

KV模式不变，但V是一个键值对

hset/hget/hmset/hmget/hgetall/hdel

hset:hset key field value 

hget:hget key field

hmset:hmset key field value [field value ...]

hdel:hdel key field [field ...]

hlen:hlen key

hexists:hexists key field

[获取所有的key]
hkeys: hkeys key

[获取所有的值]
hvals:hvals key

hincrby:hincrby key field increment

hincrbyfloat:hincrbyfloat key field increment

hsetnx


##### Zset 

zadd:zadd key [NX|XX] [CH] [INCR] score member [score member ...]

zrange:zrange key start stop [WITHSCORES] eg:zrange zset01 0 -1 withscores

zrangebyscore:zrangebyscore key min max [WITHSCORES] [LIMIT offset count]

eg: zrangebyscore zset01 100 100     包含:<=100    zrangebyscore zset01 90 (100   不包含：<100 

zrem:zrem key member [member ...]

zcard: zcard key

zcount:zcount key start end

zscore:zscore key member

zrevrank:zrevrank key member 有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序

zrevrangebyscore:  

#### 持久化

       如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效，RDB的缺点是最后一次持久化后的数据可能丢失
       Rdb是整个内存的压缩过的Snapshot,Rdb的数据结构，可以配置复合的快照触发条件
        默认：
        是1分钟内改了1万次，
        或5分钟内改了10次，
        或15分钟内改了1次。


#### save 或者 bgsave
        保存

save:save时只管保存，其他不管，全部阻塞

bgsave:redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间

执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义



##### rdb [redis database]
        在指定的时间间隔内将内存中的数据集快照写入磁盘，
        也就是行话将的Snapshot快照，它恢复时就是将快照文件直接读到内存中。

##### aof [append only file]
        redis会单独创建（fork）一个子进程来进行持久化，会吸纳将数据写入到一个临时文件中，主进程是不进行任何
        IO操作的，这就确保了极高的性能
        已日志的形式来记录每个写操作，将redis执行过的所有写指令记录下来（读操作不记录）,
        只需追加文件但不可以改写文件,redis启动之初会读取改文件重新构建数据。换言之，redis
        重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
 
        AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增重写机制，
        当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，
        只保留可以恢复数据的最小指令集，可以使用bgrewriteaof

        Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大小大于64M时触发

        相同数据集的数据而言aof文件要大于rdb文件，恢复速度慢于rdb
        aof运行效率要慢于rdb,美妙同步策略效率较好，不同步效率和rdb相同

#### 事务 [ Redis 事务的执行并不是原子性的]

        可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行执行而不会被其他命令插入，
        不许加塞。[一个队列中，一次性，顺序性、排他性的执行一系列命令]
        1.批量操作在发送EXEC命令前被放入队列缓存。
        2.收到EXEC命令后进入事务执行，事务中任意命令执行失败，其余的命令依旧被执行。
        3.在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。

        multi=>....=>exec

 ##### 悲观锁/乐观锁/CAS（check and set）



